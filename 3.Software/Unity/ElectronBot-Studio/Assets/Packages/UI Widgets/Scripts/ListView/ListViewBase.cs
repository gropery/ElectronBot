// <auto-generated/>
// Auto-generated added to suppress names errors.

namespace UIWidgets
{
	using System;
	using System.Reflection;
	using System.Collections.Generic;
	using UIWidgets.Styles;
	using UnityEngine;
	using UnityEngine.Events;
	using UnityEngine.EventSystems;
	using UnityEngine.Serialization;
	using UnityEngine.UI;

	/// <summary>
	/// ListViewBase.
	/// You can use it for creating custom ListViews.
	/// </summary>
	public abstract partial class ListViewBase : UIBehaviour,
			ISelectHandler, IDeselectHandler,
			ISubmitHandler, ICancelHandler,
			IStylable, IUpgradeable
	{
		/// <summary>
		/// Range selection mode.
		/// </summary>
		public enum RangeSelectionMode
		{
			/// <summary>
			/// Range from the first selected item to the new selected item.
			/// </summary>
			StartFromFirst = 1,

			/// <summary>
			/// Range from the last selected item to new selected item.
			/// </summary>
			StartFromLast = 0,
		}

		/// <summary>
		/// Items.
		/// </summary>
		[SerializeField]
		[HideInInspector]
		protected List<ListViewItem> items = new List<ListViewItem>();

		/// <summary>
		/// Gets or sets the items.
		/// </summary>
		/// <value>Items.</value>
		protected List<ListViewItem> Items
		{
			get
			{
				return new List<ListViewItem>(items);
			}

			set
			{
				UpdateComponents(value);
			}
		}

		/// <summary>
		/// The destroy game objects after setting new items.
		/// </summary>
		[SerializeField]
		[HideInInspector]
		public bool DestroyGameObjects = true;

		[SerializeField]
		[FormerlySerializedAs("Multiple")]
		[FormerlySerializedAs("multiple")]
		bool multipleSelect;

		/// <summary>
		/// Allow select multiple items.
		/// </summary>
		public bool MultipleSelect
		{
			get
			{
				return multipleSelect;
			}

			set
			{
				if (!value && selectedIndices.Count > 1)
				{
					var deselect = SelectedIndicesList;
					for (int i = 0; i < deselect.Count - 1; i++)
					{
						Deselect(deselect[i]);
					}
				}

				multipleSelect = value;
			}
		}

		/// <summary>
		/// Allow select multiple items.
		/// </summary>
		[Obsolete("Use MultipleSelect instead.")]
		public bool Multiple
		{
			get
			{
				return MultipleSelect;
			}

			set
			{
				MultipleSelect = value;
			}
		}

		#if UNITY_EDITOR
		/// <summary>
		/// Validate this instance.
		/// </summary>
		protected override void OnValidate()
		{
			base.OnValidate();
			MultipleSelect = multipleSelect;
		}
		#endif

		[SerializeField]
		int selectedIndex = -1;

		/// <summary>
		/// Gets or sets the index of the selected item.
		/// </summary>
		/// <value>The index of the selected.</value>
		public int SelectedIndex
		{
			get
			{
				return selectedIndex;
			}

			set
			{
				if (value == -1)
				{
					if (selectedIndex != -1)
					{
						Deselect(selectedIndex);
					}

					selectedIndex = value;
				}
				else
				{
					Select(value);
				}
			}
		}

		/// <summary>
		/// Selected indices.
		/// </summary>
		[SerializeField]
		[FormerlySerializedAs("selectedIndicies")]
		protected LinkedHashSet<int> selectedIndices = new LinkedHashSet<int>();

		List<int> selectedIndicesList = new List<int>();

		List<int> tempDeselect = new List<int>();

		List<int> tempSelect = new List<int>();

		/// <summary>
		/// Gets or sets indices of the selected items.
		/// </summary>
		/// <value>The selected indices.</value>
		public List<int> SelectedIndices
		{
			get
			{
				return selectedIndices.Items();
			}

			set
			{
				foreach (var index in selectedIndices)
				{
					if (!value.Contains(index))
					{
						tempDeselect.Add(index);
					}
				}

				foreach (var index in value)
				{
					if (!selectedIndices.Contains(index))
					{
						tempSelect.Add(index);
					}
				}

				foreach (var index in tempDeselect)
				{
					Deselect(index);
				}
				tempDeselect.Clear();

				foreach (var index in tempSelect)
				{
					Select(index);
				}
				tempSelect.Clear();
			}
		}

		/// <summary>
		/// Gets or sets indices of the selected items.
		/// </summary>
		/// <value>The selected indices.</value>
		[Obsolete("Use SelectedIndices.")]
		public List<int> SelectedIndicies
		{
			get
			{
				return SelectedIndices;
			}

			set
			{
				SelectedIndices = value;
			}
		}

		/// <summary>
		/// Reusable selected indices list.
		/// </summary>
		protected List<int> SelectedIndicesList
		{
			get
			{
				selectedIndicesList.Clear();
				selectedIndices.GetItems(selectedIndicesList);

				return selectedIndicesList;
			}
		}

		/// <summary>
		/// Range selection mode.
		/// </summary>
		[SerializeField]
		[Tooltip("Which element is the start when selecting a range with the Shift key.")]
		public RangeSelectionMode RangeMode = RangeSelectionMode.StartFromFirst;

		/// <summary>
		/// Apply style for the table instead of ListView style.
		/// </summary>
		[SerializeField]
		[FormerlySerializedAs("IsTable")]
		[Tooltip("Is ListView will be displayed as a table?\nUsed for correct styles support.")]
		public bool StyleTable;

		/// <summary>
		/// Apply style for the table instead of ListView style.
		/// </summary>
		[Obsolete("Use StyleTable.")]
		public bool IsTable
		{
			get
			{
				return StyleTable;
			}

			set
			{
				StyleTable = value;
			}
		}

		/// <summary>
		/// List can be looped and items is enough to make looped list.
		/// </summary>
		/// <value><c>true</c> if looped list available; otherwise, <c>false</c>.</value>
		public virtual bool LoopedListAvailable
		{
			get
			{
				return false;
			}
		}

		/// <summary>
		/// Allow navigation.
		/// </summary>
		[SerializeField]
		public bool Navigation = true;

		/// <summary>
		/// OnSelect event.
		/// </summary>
		[SerializeField]
		public ListViewBaseEvent OnSelect = new ListViewBaseEvent();

		/// <summary>
		/// OnDeselect event.
		/// </summary>
		[SerializeField]
		public ListViewBaseEvent OnDeselect = new ListViewBaseEvent();

		/// <summary>
		/// OnSubmit event.
		/// </summary>
		[SerializeField]
		public UnityEvent onSubmit = new UnityEvent();

		/// <summary>
		/// OnCancel event.
		/// </summary>
		[SerializeField]
		public UnityEvent onCancel = new UnityEvent();

		/// <summary>
		/// OnItemSelect event.
		/// </summary>
		[SerializeField]
		[Obsolete("Replaced with ItemsEvents.Select")]
		public UnityEvent onItemSelect = new UnityEvent();

		/// <summary>
		/// onItemCancel event.
		/// </summary>
		[SerializeField]
		[Obsolete("Replaced with ItemsEvents.Cancel")]
		public UnityEvent onItemCancel = new UnityEvent();

		/// <summary>
		/// The container for items objects.
		/// </summary>
		[SerializeField]
		public RectTransform Container;

		/// <summary>
		/// Container.anchoredPosition wrapper.
		/// </summary>
		protected Vector2 ContainerAnchoredPosition
		{
			get
			{
				var pos = Container.anchoredPosition;
				var scale = Container.localScale;
				return new Vector2(pos.x / scale.x, pos.y / scale.y);
			}

			set
			{
				var scale = Container.localScale;
				Container.anchoredPosition = new Vector2(value.x * scale.x, value.y * scale.y);
			}
		}

		/// <summary>
		/// OnFocusIn event.
		/// </summary>
		[SerializeField]
		public ListViewFocusEvent OnFocusIn = new ListViewFocusEvent();

		/// <summary>
		/// OnFocusOut event.
		/// </summary>
		[SerializeField]
		public ListViewFocusEvent OnFocusOut = new ListViewFocusEvent();

		/// <summary>
		/// Callback after UpdateView() call.
		/// </summary>
		[SerializeField]
		public UnityEvent OnUpdateView = new UnityEvent();

		/// <summary>
		/// What to do when the event system send a pointer enter Event.
		/// </summary>
		[SerializeField]
		[Obsolete("Replaced with ItemsEvents.PointerEnter.")]
		public ListViewCustomEvent OnPointerEnterObject = new ListViewCustomEvent();

		/// <summary>
		/// What to do when the event system send a pointer exit Event.
		/// </summary>
		[SerializeField]
		[Obsolete("Replaced with ItemsEvents.PointerExit.")]
		public ListViewCustomEvent OnPointerExitObject = new ListViewCustomEvent();

		[NonSerialized]
		bool isListViewBaseInited;

		/// <summary>
		/// Determinate if index can be selected.
		/// </summary>
		public Func<int, bool> CanSelect = AlwaysAllow;

		/// <summary>
		/// Determinate if index can be deselected.
		/// </summary>
		public Func<int, bool> CanDeselect = AlwaysAllow;

		/// <summary>
		/// ListViewItem events.
		/// </summary>
		[SerializeField]
		public ListViewItemEvents ItemsEvents = new ListViewItemEvents();

		[NonSerialized]
		Selectable selectable;

		/// <summary>
		/// Selectable.
		/// </summary>
		protected Selectable Selectable
		{
			get
			{
				if (selectable == null)
				{
					selectable = GetComponent<Selectable>();
				}

				return selectable;
			}
		}

		/// <summary>
		/// Default function to check if index can be selected or deselected.
		/// </summary>
		/// <param name="index">Index.</param>
		/// <returns>true.</returns>
		public static bool AlwaysAllow(int index)
		{
			return true;
		}

		/// <summary>
		/// Start this instance.
		/// </summary>
		public virtual new void Start()
		{
			base.Start();

			Upgrade();
			Init();
		}

		/// <summary>
		/// Init this instance.
		/// </summary>
		public virtual void Init()
		{
			if (isListViewBaseInited)
			{
				return;
			}

			isListViewBaseInited = true;

			Upgrade();

			if ((selectedIndex != -1) && (selectedIndices.Count == 0))
			{
				selectedIndices.Add(selectedIndex);
			}

			selectedIndices.RemoveWhere(NotIsValid);
			if (selectedIndices.Count == 0)
			{
				selectedIndex = -1;
			}

			OnCanvasGroupChanged();

			AddCallbacks();
		}

		/// <summary>
		/// Gets indices of the selected items.
		/// </summary>
		public void GetSelectedIndices(List<int> output)
		{
			selectedIndices.GetItems(output);
		}

		/// <summary>
		/// Determines if item not exists with the specified index.
		/// </summary>
		/// <returns><c>true</c>, if item not exists, <c>false</c> otherwise.</returns>
		/// <param name="index">Index.</param>
		protected bool NotIsValid(int index)
		{
			return !IsValid(index);
		}

		/// <summary>
		/// Is visible item with specified index.
		/// </summary>
		/// <param name="index">Index.</param>
		/// <param name="minVisiblePart">The minimal visible part of the item to consider item visible.</param>
		/// <returns>true if item visible; false otherwise.</returns>
		public virtual bool IsVisible(int index, float minVisiblePart = 0f)
		{
			return false;
		}

		/// <summary>
		/// Is component instance exists for the item with specified index.
		/// </summary>
		/// <returns><c>true</c> if component exists; otherwise, <c>false</c>.</returns>
		/// <param name="index">Index.</param>
		public virtual bool IsItemVisible(int index)
		{
			return false;
		}

		/// <summary>
		/// Determines whether this instance is horizontal. Not implemented for ListViewBase.
		/// </summary>
		/// <returns><c>true</c> if this instance is horizontal; otherwise, <c>false</c>.</returns>
		public virtual bool IsHorizontal()
		{
			throw new NotSupportedException();
		}

		/// <summary>
		/// Gets the default height of the item. Not implemented for ListViewBase.
		/// </summary>
		/// <returns>The default item height.</returns>
		public virtual float GetDefaultItemHeight()
		{
			throw new NotSupportedException();
		}

		/// <summary>
		/// Gets the default width of the item. Not implemented for ListViewBase.
		/// </summary>
		/// <returns>The default item width.</returns>
		public virtual float GetDefaultItemWidth()
		{
			throw new NotSupportedException();
		}

		/// <summary>
		/// Gets the spacing between items. Not implemented for ListViewBase.
		/// </summary>
		/// <returns>The item spacing.</returns>
		public virtual float GetItemSpacing()
		{
			throw new NotSupportedException();
		}

		/// <summary>
		/// Gets the horizontal spacing between items. Not implemented for ListViewBase.
		/// </summary>
		/// <returns>The item spacing.</returns>
		public virtual float GetItemSpacingX()
		{
			throw new NotSupportedException();
		}

		/// <summary>
		/// Gets the vertical spacing between items. Not implemented for ListViewBase.
		/// </summary>
		/// <returns>The item spacing.</returns>
		public virtual float GetItemSpacingY()
		{
			throw new NotSupportedException();
		}

		/// <summary>
		/// Gets the layout margin.
		/// </summary>
		/// <returns>The layout margin.</returns>
		public virtual Vector4 GetLayoutMargin()
		{
			throw new NotSupportedException();
		}

		/// <summary>
		/// Process the item cancel event.
		/// </summary>
		/// <param name="index">Index.</param>
		/// <param name="item">Item.</param>
		/// <param name="eventData">Event data.</param>
		void OnItemCancel(int index, ListViewItem item, BaseEventData eventData)
		{
			if (EventSystem.current.alreadySelecting)
			{
				return;
			}

			EventSystem.current.SetSelectedGameObject(gameObject);

			#pragma warning disable 0618
			onItemCancel.Invoke();
			#pragma warning restore 0618
		}

		/// <summary>
		/// Adds the callbacks.
		/// </summary>
		void AddCallbacks()
		{
			ItemsEvents.Cancel.AddListener(OnItemCancel);
			ItemsEvents.Move.AddListener(OnItemMove);
			ItemsEvents.Select.AddListener(OnItemSelect);
			ItemsEvents.Deselect.AddListener(OnItemDeselect);

			ItemsEvents.PointerEnter.AddListener(OnItemPointerEnter);
			ItemsEvents.PointerExit.AddListener(OnItemPointerExit);
		}

		/// <summary>
		/// Removes the callbacks.
		/// </summary>
		void RemoveCallbacks()
		{
			ItemsEvents.Cancel.RemoveListener(OnItemCancel);
			ItemsEvents.Move.RemoveListener(OnItemMove);
			ItemsEvents.Select.RemoveListener(OnItemSelect);
			ItemsEvents.Deselect.RemoveListener(OnItemDeselect);

			ItemsEvents.PointerEnter.RemoveListener(OnItemPointerEnter);
			ItemsEvents.PointerExit.RemoveListener(OnItemPointerExit);
		}

		/// <summary>
		/// Item highlighted by pointer event.
		/// </summary>
		protected ListViewItem CurrentPointerHighlightedItem;

		/// <summary>
		/// Process the pointer enter callback event.
		/// </summary>
		/// <param name="index">Index.</param>
		/// <param name="item">Item.</param>
		/// <param name="eventData">Event data.</param>
		protected virtual void OnItemPointerEnter(int index, ListViewItem item, PointerEventData eventData)
		{
			#pragma warning disable 0618
			OnPointerEnterObject.Invoke(item.Index);
			#pragma warning restore 0618

			if ((CurrentPointerHighlightedItem != null) && IsValid(CurrentPointerHighlightedItem.Index))
			{
				Coloring(CurrentPointerHighlightedItem);
				if (IsSelected(CurrentPointerHighlightedItem.Index))
				{
					CurrentPointerHighlightedItem.StateSelected();
				}
				else
				{
					CurrentPointerHighlightedItem.StateDefault();
				}
			}

			CurrentPointerHighlightedItem = item;
			if (!IsSelected(item.Index))
			{
				HighlightColoring(item);
				item.StateHighlighted();
			}
		}

		/// <summary>
		/// Process the pointer enter callback event.
		/// </summary>
		/// <param name="index">Index.</param>
		/// <param name="item">Item.</param>
		/// <param name="eventData">Event data.</param>
		protected virtual void OnItemPointerExit(int index, ListViewItem item, PointerEventData eventData)
		{
			#pragma warning disable 0618
			OnPointerExitObject.Invoke(item.Index);
			#pragma warning restore 0618

			if (!IsSelected(item.Index))
			{
				DefaultColoring(item);
				item.StateDefault();
			}
		}

		/// <summary>
		/// Process the item select event.
		/// </summary>
		/// <param name="index">Index.</param>
		/// <param name="item">Item.</param>
		/// <param name="eventData">Event data.</param>
		protected virtual void OnItemDeselect(int index, ListViewItem item, BaseEventData eventData)
		{
			Coloring(item);
		}

		/// <summary>
		/// Process the item select event.
		/// </summary>
		/// <param name="index">Index.</param>
		/// <param name="item">Item.</param>
		/// <param name="eventData">Event data.</param>
		protected virtual void OnItemSelect(int index, ListViewItem item, BaseEventData eventData)
		{
			#pragma warning disable 0618
			onItemSelect.Invoke();
			#pragma warning restore 0618

			HighlightColoring(item);
		}

		/// <summary>
		/// Process the item move event.
		/// </summary>
		/// <param name="index">Index.</param>
		/// <param name="item">Item.</param>
		/// <param name="eventData">Event data.</param>
		protected virtual void OnItemMove(int index, ListViewItem item, AxisEventData eventData)
		{
			if (!Navigation)
			{
				return;
			}

			if (Selectable != null)
			{
				Selectable.OnMove(eventData);
			}
		}

		/// <summary>
		/// Scrolls to item with specified index.
		/// </summary>
		/// <param name="index">Index.</param>
		public virtual void ScrollTo(int index)
		{
		}

		/// <summary>
		/// Add the specified item.
		/// </summary>
		/// <param name="item">Item.</param>
		/// <returns>Index of added item.</returns>
		public virtual int Add(ListViewItem item)
		{
			if (item.transform.parent != Container)
			{
				item.transform.SetParent(Container, false);
			}

			items.Add(item);
			item.Owner = this;
			item.Index = items.Count - 1;

			return items.Count - 1;
		}

		/// <summary>
		/// Clear items of this instance.
		/// </summary>
		public virtual void Clear()
		{
			UpdateComponents(items);
		}

		/// <summary>
		/// Remove the item with the specified index.
		/// </summary>
		/// <param name="index">Index.</param>
		public abstract void RemoveItemAt(int index);

		/// <summary>
		/// Remove the specified item.
		/// </summary>
		/// <param name="item">Item.</param>
		/// <returns>Index of removed item.</returns>
		protected virtual int Remove(ListViewItem item)
		{
			var index = item.Index;

			var prev_selected_indices = SelectedIndicesList;
			selectedIndices.Clear();
			foreach (var old_index in prev_selected_indices)
			{
				if (old_index != index)
				{
					selectedIndices.Add(old_index > index ? old_index - 1 : old_index);
				}
			}

			if (selectedIndex == index)
			{
				Deselect(index);
				selectedIndex = selectedIndices.Count > 0 ? selectedIndices.Last() : -1;
			}
			else if (selectedIndex > index)
			{
				selectedIndex -= 1;
			}

			items.Remove(item);
			Free(item);

			return index;
		}

		/// <summary>
		/// Free the specified item.
		/// </summary>
		/// <param name="item">Item.</param>
		void Free(ListViewItem item)
		{
			if (item == null)
			{
				return;
			}

			item.Owner = null;
		}

		/// <summary>
		/// Update items.
		/// </summary>
		public abstract void UpdateItems();

		/// <summary>
		/// Updates the items.
		/// </summary>
		/// <param name="newItems">New items.</param>
		protected virtual void UpdateComponents<TItem>(List<TItem> newItems)
			where TItem : ListViewItem
		{
			for (int i = 0; i < items.Count; i++)
			{
				if ((items[i] != null) && (!newItems.Contains(items[i] as TItem)))
				{
					Free(items[i]);
				}
			}

			items.Clear();
			for (int i = 0; i < newItems.Count; i++)
			{
				newItems[i].transform.SetParent(Container, false);
				newItems[i].Owner = this;
				items.Add(newItems[i]);
			}
		}

		/// <summary>
		/// Determines if item exists with the specified index.
		/// </summary>
		/// <returns><c>true</c> if item exists with the specified index; otherwise, <c>false</c>.</returns>
		/// <param name="index">Index.</param>
		public virtual bool IsValid(int index)
		{
			return (index >= 0) && (index < items.Count);
		}

		/// <summary>
		/// Gets the item.
		/// </summary>
		/// <returns>The item.</returns>
		/// <param name="index">Index.</param>
		protected ListViewItem GetComponent(int index)
		{
			for (int i = 0; i < items.Count; i++)
			{
				if (items[i].Index == index)
				{
					return items[i];
				}
			}

			return null;
		}

		/// <summary>
		/// Select item by the specified index.
		/// </summary>
		/// <param name="index">Index.</param>
		public void Select(int index)
		{
			Select(index, true);
		}

		/// <summary>
		/// Select item by the specified index.
		/// </summary>
		/// <param name="index">Index.</param>
		/// <param name="raiseEvents">Raise select events?</param>
		public virtual void Select(int index, bool raiseEvents)
		{
			if (index < 0)
			{
				return;
			}

			if (!IsValid(index))
			{
				var message = string.Format("Index must be between 0 and Items.Count ({0}), but {2}, Gameobject {1}.", (items.Count - 1).ToString(), name, index.ToString());
				throw new IndexOutOfRangeException(message);
			}

			if (IsSelected(index))
			{
				return;
			}

			if (!CanBeSelected(index))
			{
				return;
			}

			if (!MultipleSelect)
			{
				if ((selectedIndex != -1) && (selectedIndex != index))
				{
					Deselect(selectedIndex);
				}

				selectedIndices.Clear();
			}

			selectedIndices.Add(index);
			selectedIndex = index;

			SelectItem(index);

			InvokeSelect(index, raiseEvents);
		}

		/// <summary>
		/// Determines whether if item with specified index can be selected.
		/// </summary>
		/// <returns><c>true</c> if item with specified index can be selected; otherwise, <c>false</c>.</returns>
		/// <param name="index">Index.</param>
		protected virtual bool CanBeSelected(int index)
		{
			return CanSelect(index);
		}

		/// <summary>
		/// Determines whether if item with specified index can be deselected.
		/// </summary>
		/// <returns><c>true</c> if item with specified index can be deselected; otherwise, <c>false</c>.</returns>
		/// <param name="index">Index.</param>
		protected virtual bool CanBeDeselected(int index)
		{
			return CanDeselect(index);
		}

		/// <summary>
		/// Invokes the select event.
		/// </summary>
		/// <param name="index">Index.</param>
		/// <param name="raiseEvents">Raise select events?</param>
		protected virtual void InvokeSelect(int index, bool raiseEvents)
		{
			if (!IsValid(index))
			{
				Debug.LogWarning(string.Format("Incorrect index: {0}", index.ToString()), this);
			}

			if (raiseEvents)
			{
				OnSelect.Invoke(index, GetComponent(index));
			}
		}

		/// <summary>
		/// Invokes the deselect event.
		/// </summary>
		/// <param name="index">Index.</param>
		/// <param name="raiseEvents">Raise select events?</param>
		protected virtual void InvokeDeselect(int index, bool raiseEvents)
		{
			if (!IsValid(index))
			{
				Debug.LogWarning(string.Format("Incorrect index: {0}", index.ToString()), this);
			}

			if (raiseEvents)
			{
				OnDeselect.Invoke(index, GetComponent(index));
			}
		}

		/// <summary>
		/// Deselect specified indices without raising corresponding events (OnDeselect, etc).
		/// </summary>
		/// <param name="indices">Indices.</param>
		protected virtual void SilentDeselect(List<int> indices)
		{
			if (indices == null)
			{
				return;
			}

			foreach (var index in indices)
			{
				selectedIndices.Remove(index);
			}

			selectedIndex = (selectedIndices.Count > 0) ? selectedIndices.Last() : -1;
		}

		/// <summary>
		/// Select specified indices without raising corresponding events (OnSelect, etc).
		/// </summary>
		/// <param name="indices">Indices.</param>
		protected virtual void SilentSelect(List<int> indices)
		{
			if (indices == null)
			{
				return;
			}

			foreach (var index in indices)
			{
				selectedIndices.Add(index);
			}

			selectedIndex = (selectedIndices.Count > 0) ? selectedIndices.Last() : -1;
		}

		/// <summary>
		/// Deselect item by the specified index.
		/// </summary>
		/// <param name="index">Index.</param>
		public void Deselect(int index)
		{
			Deselect(index, true);
		}

		/// <summary>
		/// Deselect all items.
		/// </summary>
		/// <param name="raiseEvents">Raise select events?</param>
		public void DeselectAll(bool raiseEvents = true)
		{
			GetSelectedIndices(tempSelect);

			foreach (var index in tempSelect)
			{
				Deselect(index, raiseEvents);
			}

			tempSelect.Clear();
		}

		/// <summary>
		/// Deselect item by the specified index.
		/// </summary>
		/// <param name="index">Index.</param>
		/// <param name="raiseEvents">Raise select events?</param>
		public void Deselect(int index, bool raiseEvents)
		{
			if (index < 0)
			{
				return;
			}

			if (!IsSelected(index))
			{
				return;
			}

			if (!CanBeDeselected(index))
			{
				return;
			}

			selectedIndices.Remove(index);
			selectedIndex = (selectedIndices.Count > 0) ? selectedIndices.Last() : -1;

			if (IsValid(index))
			{
				DeselectItem(index);

				InvokeDeselect(index, raiseEvents);
			}
		}

		/// <summary>
		/// Determines if item is selected with the specified index.
		/// </summary>
		/// <returns><c>true</c> if item is selected with the specified index; otherwise, <c>false</c>.</returns>
		/// <param name="index">Index.</param>
		public virtual bool IsSelected(int index)
		{
			return selectedIndices.Contains(index);
		}

		/// <summary>
		/// Toggle item by the specified index.
		/// </summary>
		/// <param name="index">Index.</param>
		public void Toggle(int index)
		{
			if (IsSelected(index) && MultipleSelect)
			{
				Deselect(index);
			}
			else
			{
				Select(index);
			}
		}

		/// <summary>
		/// Toggle the specified index.
		/// </summary>
		/// <param name="index">Index.</param>
		public virtual void ItemToggle(int index)
		{
			var shift_pressed = CompatibilityInput.IsShiftPressed;
			var have_selected = selectedIndices.Count > 0;
			var last_selected = selectedIndex;
			if (MultipleSelect && shift_pressed && have_selected && last_selected != index)
			{
				var start_index = RangeMode == RangeSelectionMode.StartFromFirst
					? selectedIndices.First()
					: selectedIndices.Last();

				// deselect all items
				tempDeselect.AddRange(selectedIndices);
				foreach (var i in tempDeselect)
				{
					Deselect(i);
				}
				tempDeselect.Clear();

				// find min and max indices
				var min = Mathf.Min(start_index, index);
				var max = Mathf.Max(start_index, index);

				// select items from min to max
				for (int i = min; i < max + 1; i++)
				{
					Select(i);
				}
			}
			else
			{
				Toggle(index);
			}

			if (!IsSelected(index))
			{
				var item = GetComponent(index);
				if (item != null)
				{
					HighlightColoring(item);
				}
			}
		}

		/// <summary>
		/// Move the component transform to the end of the local transform list.
		/// </summary>
		/// <param name="item">Item.</param>
		protected static void SetComponentAsLastSibling(Component item)
		{
			item.transform.SetAsLastSibling();
		}

		/// <summary>
		/// Called when item selected.
		/// Use it for change visible style of selected item.
		/// </summary>
		/// <param name="index">Index.</param>
		protected virtual void SelectItem(int index)
		{
		}

		/// <summary>
		/// Called when item deselected.
		/// Use it for change visible style of deselected item.
		/// </summary>
		/// <param name="index">Index.</param>
		protected virtual void DeselectItem(int index)
		{
		}

		/// <summary>
		/// Updates the colors.
		/// </summary>
		/// <param name="instant">Is should be instant color update?</param>
		public virtual void ComponentsColoring(bool instant = false)
		{
		}

		/// <summary>
		/// Coloring the specified component.
		/// </summary>
		/// <param name="component">Component.</param>
		protected virtual void Coloring(ListViewItem component)
		{
		}

		/// <summary>
		/// Set default colors of specified component.
		/// </summary>
		/// <param name="component">Component.</param>
		protected virtual void DefaultColoring(ListViewItem component)
		{
		}

		/// <summary>
		/// Set highlights colors of specified component.
		/// </summary>
		/// <param name="component">Component.</param>
		protected virtual void HighlightColoring(ListViewItem component)
		{
		}

		/// <summary>
		/// This function is called when the MonoBehaviour will be destroyed.
		/// </summary>
		protected override void OnDestroy()
		{
			base.OnDestroy();

			RemoveCallbacks();

			foreach (var item in items)
			{
				Free(item);
			}
			items.Clear();
		}

		/// <summary>
		/// Set EventSystem.current.SetSelectedGameObject with selected or first item.
		/// </summary>
		/// <returns><c>true</c>, if component was selected, <c>false</c> otherwise.</returns>
		public virtual bool SelectComponent()
		{
			if (items.Count == 0)
			{
				return false;
			}

			var index = (SelectedIndex != -1) ? SelectedIndex : 0;
			SelectComponentByIndex(index);

			return true;
		}

		/// <summary>
		/// Selects the component by index.
		/// </summary>
		/// <param name="index">Index.</param>
		public void SelectComponentByIndex(int index)
		{
			if (!IsValid(index))
			{
				return;
			}

			ScrollTo(index);

			var component = GetComponent(index);
			if (component != null)
			{
				EventSystem.current.SetSelectedGameObject(component.gameObject);
			}
		}

		/// <summary>
		/// Navigate to the specified target.
		/// </summary>
		/// <param name="eventData">Event data.</param>
		/// <param name="target">Target.</param>
		protected virtual void Navigate(AxisEventData eventData, Selectable target)
		{
			if (target != null && target.IsActive())
			{
				eventData.selectedObject = target.gameObject;
			}
		}

		/// <summary>
		/// Navigate to the item with specified index.
		/// </summary>
		/// <param name="eventData">Event data.</param>
		/// <param name="index">Index.</param>
		/// <returns>true if navigation successful; otherwise false.</returns>
		protected virtual bool Navigate(AxisEventData eventData, int index)
		{
			if (!IsValid(index))
			{
				return false;
			}

			ScrollTo(index);

			var component = GetComponent(index);
			if (component == null)
			{
				return false;
			}

			eventData.Use();
			eventData.selectedObject = component.gameObject;

			return true;
		}

		/// <summary>
		/// Selects the component by index.
		/// </summary>
		/// <param name="eventData">Event data.</param>
		/// <param name="index">Index.</param>
		[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Design", "CA1011:ConsiderPassingBaseTypesAsParameters", Justification = "Reviewed.")]
		public void SelectComponentByIndex(AxisEventData eventData, int index)
		{
			Navigate(eventData, index);
		}

		/// <summary>
		/// Handle select event.
		/// </summary>
		/// <param name="eventData">Event data.</param>
		void ISelectHandler.OnSelect(BaseEventData eventData)
		{
			SelectHandlerOnSelect(eventData);
		}

		/// <summary>
		/// Handle select event.
		/// </summary>
		/// <param name="eventData">Event data.</param>
		protected virtual void SelectHandlerOnSelect(BaseEventData eventData)
		{
			if (!EventSystem.current.alreadySelecting)
			{
				EventSystem.current.SetSelectedGameObject(gameObject);
			}

			OnFocusIn.Invoke(eventData);
		}

		/// <summary>
		/// Handle deselect event.
		/// </summary>
		/// <param name="eventData">Current event data.</param>
		void IDeselectHandler.OnDeselect(BaseEventData eventData)
		{
			DeselectHandlerOnDeselect(eventData);
		}

		/// <summary>
		/// Handle deselect event.
		/// </summary>
		/// <param name="eventData">Current event data.</param>
		protected virtual void DeselectHandlerOnDeselect(BaseEventData eventData)
		{
			OnFocusOut.Invoke(eventData);
		}

		/// <summary>
		/// Handle submit event.
		/// </summary>
		/// <param name="eventData">Event data.</param>
		void ISubmitHandler.OnSubmit(BaseEventData eventData)
		{
			SubmitHandlerOnSubmit(eventData);
		}

		/// <summary>
		/// Handle submit event.
		/// </summary>
		/// <param name="eventData">Event data.</param>
		protected virtual void SubmitHandlerOnSubmit(BaseEventData eventData)
		{
			SelectComponent();
			onSubmit.Invoke();
		}

		/// <summary>
		/// Handle cancel event.
		/// </summary>
		/// <param name="eventData">Event data.</param>
		void ICancelHandler.OnCancel(BaseEventData eventData)
		{
			CancelHandlerOnCancel(eventData);
		}

		/// <summary>
		/// Handle cancel event.
		/// </summary>
		/// <param name="eventData">Event data.</param>
		protected virtual void CancelHandlerOnCancel(BaseEventData eventData)
		{
			onCancel.Invoke();
		}

		/// <summary>
		/// Calls specified function with each component.
		/// </summary>
		/// <param name="func">Function to apply for each component.</param>
		public virtual void ForEachComponent(Action<ListViewItem> func)
		{
			foreach (var item in items)
			{
				func(item);
			}
		}

		/// <summary>
		/// Calls specified function with each component.
		/// </summary>
		/// <param name="func">Function to apply for each component.</param>
		/// <typeparam name="T">Actual type of components.</typeparam>
		protected virtual void ForEachComponent<T>(Action<T> func)
			where T : ListViewItem
		{
			for (int i = 0; i < items.Count; i++)
			{
				func(items[i] as T);
			}
		}

		#region DebugInfo

		/// <summary>
		/// Print debug information to console log.
		/// </summary>
		public void PrintDebugInfo()
		{
			Debug.Log(GetDebugInfo(), this);
		}

		/// <summary>
		/// Get debug information.
		/// </summary>
		/// <returns>Debug information.</returns>
		public virtual string GetDebugInfo()
		{
			throw new NotSupportedException();
		}
		#endregion

		#region ListViewPaginator support

		/// <summary>
		/// Gets the ScrollRect.
		/// </summary>
		/// <returns>The ScrollRect.</returns>
		public virtual ScrollRect GetScrollRect()
		{
			throw new NotSupportedException();
		}

		/// <summary>
		/// Gets the items count.
		/// </summary>
		/// <returns>The items count.</returns>
		public virtual int GetItemsCount()
		{
			throw new NotSupportedException();
		}

		/// <summary>
		/// Gets the items per block count.
		/// </summary>
		/// <returns>The items per block.</returns>
		public virtual int GetItemsPerBlock()
		{
			throw new NotSupportedException();
		}

		/// <summary>
		/// Gets the item position by index.
		/// </summary>
		/// <returns>The item position.</returns>
		/// <param name="index">Index.</param>
		public virtual float GetItemPosition(int index)
		{
			throw new NotSupportedException();
		}

		/// <summary>
		/// Gets the item position by index.
		/// </summary>
		/// <returns>The item position.</returns>
		/// <param name="index">Index.</param>
		public virtual float GetItemPositionBorderEnd(int index)
		{
			throw new NotSupportedException();
		}

		/// <summary>
		/// Gets the item middle position by index.
		/// </summary>
		/// <returns>The item middle position.</returns>
		/// <param name="index">Index.</param>
		public virtual float GetItemPositionMiddle(int index)
		{
			throw new NotSupportedException();
		}

		/// <summary>
		/// Gets the item bottom position by index.
		/// </summary>
		/// <returns>The item bottom position.</returns>
		/// <param name="index">Index.</param>
		public virtual float GetItemPositionBottom(int index)
		{
			throw new NotSupportedException();
		}

		/// <summary>
		/// Gets the index of the nearest item.
		/// </summary>
		/// <returns>The nearest item index.</returns>
		public virtual int GetNearestItemIndex()
		{
			throw new NotSupportedException();
		}

		/// <summary>
		/// Gets the size of the DefaultItem.
		/// </summary>
		/// <returns>Size.</returns>
		public virtual Vector2 GetDefaultItemSize()
		{
			throw new NotSupportedException();
		}

		#endregion

		#region functions to override in ListViewCustom

		/// <summary>
		/// Determines whether is sort enabled.
		/// </summary>
		/// <returns><c>true</c> if is sort enabled; otherwise, <c>false</c>.</returns>
		public virtual bool IsSortEnabled()
		{
			return false;
		}

		/// <summary>
		/// Gets the index of the nearest item.
		/// </summary>
		/// <returns>The nearest index.</returns>
		/// <param name="eventData">Event data.</param>
		public int GetNearestIndex(PointerEventData eventData)
		{
			if (IsSortEnabled())
			{
				return -1;
			}

			return GetNearestIndex(eventData, NearestType.Auto);
		}

		/// <summary>
		/// Gets the index of the nearest item.
		/// </summary>
		/// <returns>The nearest index.</returns>
		/// <param name="eventData">Event data.</param>
		/// <param name="type">Preferable nearest index.</param>
		public virtual int GetNearestIndex(PointerEventData eventData, NearestType type)
		{
			throw new NotSupportedException();
		}

		/// <summary>
		/// Gets the index of the nearest item.
		/// </summary>
		/// <returns>The nearest item index.</returns>
		/// <param name="point">Point.</param>
		public int GetNearestIndex(Vector2 point)
		{
			return GetNearestIndex(point, NearestType.Auto);
		}

		/// <summary>
		/// Gets the index of the nearest item.
		/// </summary>
		/// <returns>The nearest item index.</returns>
		/// <param name="point">Point.</param>
		/// <param name="type">Preferable nearest index.</param>
		public virtual int GetNearestIndex(Vector2 point, NearestType type)
		{
			throw new NotSupportedException();
		}

		/// <summary>
		/// Get scroll position.
		/// </summary>
		/// <returns>Position.</returns>
		public virtual float GetScrollPosition()
		{
			throw new NotSupportedException();
		}

		/// <summary>
		/// Scrolls to specified position.
		/// </summary>
		/// <param name="position">Position.</param>
		public virtual void ScrollToPosition(float position)
		{
			throw new NotSupportedException();
		}

		/// <summary>
		/// Scrolls to specified position.
		/// </summary>
		/// <param name="position">Position.</param>
		public virtual void ScrollToPosition(Vector2 position)
		{
			throw new NotSupportedException();
		}

		/// <summary>
		/// Scroll to specified index with time.
		/// </summary>
		/// <param name="index">Index.</param>
		public virtual void ScrollToAnimated(int index)
		{
			throw new NotSupportedException();
		}

		/// <summary>
		/// Scroll to specified index with time.
		/// </summary>
		/// <param name="index">Index.</param>
		/// <param name="animation">Animation curve.</param>
		/// <param name="unscaledTime">Unscaled time.</param>
		/// <param name="after">Action to run after animation.</param>
		public virtual void ScrollToAnimated(int index, AnimationCurve animation, bool unscaledTime, Action after = null)
		{
			throw new NotSupportedException();
		}

		/// <summary>
		/// Scrolls to specified position with time.
		/// </summary>
		/// <param name="target">Position.</param>
		public virtual void ScrollToPositionAnimated(float target)
		{
			throw new NotSupportedException();
		}

		/// <summary>
		/// Scrolls to specified position with time.
		/// </summary>
		/// <param name="target">Position.</param>
		/// <param name="animation">Animation curve.</param>
		/// <param name="unscaledTime">Unscaled time.</param>
		/// <param name="after">Action to run after animation.</param>
		public virtual void ScrollToPositionAnimated(float target, AnimationCurve animation, bool unscaledTime, Action after = null)
		{
			throw new NotSupportedException();
		}

		/// <summary>
		/// Scrolls to specified position with time.
		/// </summary>
		/// <param name="target">Position.</param>
		public virtual void ScrollToPositionAnimated(Vector2 target)
		{
			throw new NotSupportedException();
		}

		/// <summary>
		/// Scrolls to specified position with time.
		/// </summary>
		/// <param name="target">Position.</param>
		/// <param name="animation">Animation curve.</param>
		/// <param name="unscaledTime">Unscaled time.</param>
		/// <param name="after">Action to run after animation.</param>
		public virtual void ScrollToPositionAnimated(Vector2 target, AnimationCurve animation, bool unscaledTime, Action after = null)
		{
			throw new NotSupportedException();
		}

		/// <summary>
		/// Stop scrolling.
		/// </summary>
		public virtual void ScrollStop()
		{
			throw new NotSupportedException();
		}

		#endregion

		#region Interactable

		[SerializeField]
		Color disabledColor = new Color32(200, 200, 200, 128);

		/// <summary>
		/// Gets or sets the disabled color when widget not interactable.
		/// </summary>
		/// <value>The color of the disabled.</value>
		public Color DisabledColor
		{
			get
			{
				return disabledColor;
			}

			set
			{
				if (disabledColor != value)
				{
					disabledColor = value;
					InteractableChanged();
				}
			}
		}

		[SerializeField]
		bool interactable = true;

		/// <summary>
		/// Is widget interactable.
		/// </summary>
		/// <value><c>true</c> if interactable; otherwise, <c>false</c>.</value>
		public bool Interactable
		{
			get
			{
				return interactable;
			}

			set
			{
				if (interactable != value)
				{
					interactable = value;
					InteractableChanged();
				}
			}
		}

		/// <summary>
		/// If the canvas groups allow interaction.
		/// </summary>
		protected bool GroupsAllowInteraction = true;

		/// <summary>
		/// The CanvasGroup cache.
		/// </summary>
		protected readonly List<CanvasGroup> CanvasGroupCache = new List<CanvasGroup>();

		/// <summary>
		/// Process the CanvasGroupChanged event.
		/// </summary>
		protected override void OnCanvasGroupChanged()
		{
			var groupAllowInteraction = true;
			var t = transform;
			while (t != null)
			{
				t.GetComponents(CanvasGroupCache);
				var shouldBreak = false;
				foreach (var canvas_group in CanvasGroupCache)
				{
					if (!canvas_group.interactable)
					{
						groupAllowInteraction = false;
						shouldBreak = true;
					}

					shouldBreak |= canvas_group.ignoreParentGroups;
				}

				if (shouldBreak)
				{
					break;
				}

				t = t.parent;
			}

			if (groupAllowInteraction != GroupsAllowInteraction)
			{
				GroupsAllowInteraction = groupAllowInteraction;
				InteractableChanged();
			}
		}

		/// <summary>
		/// Determines whether this widget is interactable.
		/// </summary>
		/// <returns><c>true</c> if this instance is interactable; otherwise, <c>false</c>.</returns>
		public virtual bool IsInteractable()
		{
			return GroupsAllowInteraction && Interactable;
		}

		/// <summary>
		/// Process interactable change.
		/// </summary>
		protected virtual void InteractableChanged()
		{
			ComponentsColoring(true);

			if (IsInteractable())
			{
				OnInteractableEnabled();
			}
			else
			{
				OnInteractableDisabled();
			}
		}

		/// <summary>
		/// What to do when widget became interactable.
		/// </summary>
		protected virtual void OnInteractableEnabled()
		{
		}

		/// <summary>
		/// What to do when widget became not interactable.
		/// </summary>
		protected virtual void OnInteractableDisabled()
		{
		}
		#endregion

		#region IStylable implementation

		/// <inheritdoc/>
		public virtual bool SetStyle(Style style)
		{
			return false;
		}

		/// <inheritdoc/>
		public virtual bool GetStyle(Style style)
		{
			return false;
		}
		#endregion

		/// <summary>
		/// Upgrade serialized data to the latest version.
		/// </summary>
		public virtual void Upgrade()
		{
		}
	}
}